# 黑客工具 讲座

*原文地址：https://hacker-tools.github.io/lectures/*

*译者按：这个内容并非是讲安全和入侵的，所以叫做黑客有些误导，实际上都是作为一个天天和计算机打交道的技术人员的背景知识，但还是得尊重原文*

**目录索引**

点击下面的链接以观看讲座视频和讲座笔记

1月15日星期二

* 课程概览
* 虚拟机们和容器们
* Shell与脚本

1月17日 星期四

* 命令行环境

* 数据清理

1月22日 星期二

* 编辑器们
* 版本控制

1月24日 星期四

* 配置文件（dotfiles）
* 备份
* 自动化
* 机器反省

**1月29日 星期二**

* 程序自省
* 程序包/依赖 管理
* 操作系统定制
* 远程机器

1月31日 星期四

* Web和浏览器们
* 安全和隐私

****

## 课程概览

### 动机

这个课程是关于黑客工具，但又不是黑客工具。（译者按：这个讲师大概是个禅门弟子）

MIT课程没有涉及任何这个内容的细节。精通你的工具是非常有好处的：它可以节约你的大量时间（并缩短你付出的时间）。

我们会教你新的工具，如何充分利用你的工具，如何定制你的工具，以及如何扩展你的工具。

### 课程结构



我们有6个讲座，涵盖各种主题。我们在网上有课堂讲稿，但课堂上会有很多内容（例如演示形式）可能不在讲稿中。我们将录制讲座。

每节课分为两节50分钟的课，中间休息10分钟。讲座主要是现场演示，然后是动手实践练习。在每节课结束时，我们可能会有一个短时间练习作业。

为了充分利用这门课，你应该自己完成所有的练习。我们希望你更多地了解您的工具，我们将向你展示各种可能性，并涵盖一些基本的细节，但我们无法在现有时间内教会您所有东西。

请在r/hackertools上发布问题。此外，我们要求你通过r/hackertools与同学分享您的知识：对于每堂课的“家庭作业”，创建一篇关于你学到的内容或您想分享的关于该主题的文章或评论。

### 讨论

你能在子论坛 [r/hackertools](https://www.reddit.com/r/hackertools)找到关于课程主题的讨论



## 虚拟机们和容器们



### 虚拟机们

虚拟机是模拟的计算机，你能够配置一个定制的虚拟机通过一些操作系统和配置，并且在不影响你的主机环境的情况下使用它们。

在这堂课上，您可以使用vms来试验操作系统、软件和配置，而不会有风险：您不会影响主要的开发环境。

一般来说，虚拟机有很多用途。它们通常用于运行仅在特定操作系统上运行的软件（例如，在Linux上使用Windows VM运行只能运行于Windows的软件）。它们通常用于试验潜在的恶意软件。

#### 优势特性

* 隔离：管理程序在将客户机与主机隔离方面做得很好，因此您可以使用虚拟机合理地安全地运行有缺陷的或不受信任的软件。
* 快照：您可以获取虚拟机的“快照”，捕获整个机器状态（磁盘、内存等），对机器进行更改，然后恢复到早期状态。这对于测试潜在的破坏性行为非常有用。

#### 缺点

虚拟机通常比在物理机上运行慢，因此它们可能不适合某些应用程序。

#### 安装

* **资源：**与宿主机共享；分配物理资源时请注意这一点。

* **网络：**许多选项，默认的NAT在大多数用例中都可以正常工作。

* **虚拟机加载项：**许多管理程序可以在虚拟机系统中安装软件，以便更好地与宿主机系统集成。如果可以的话，你应该用这个。

#### 资源

管理程序（Hypervisors）：

* virtualbox（开源）

* virt manager（开源，管理kvm虚拟机和lxc容器）

* vmware（商业版，可从IS&T获取，供麻省理工学院学生使用）

如果您已经熟悉流行的管理程序/虚拟机，那么您可能希望从命令行友好的方式了解更多关于如何实现这一点的信息。一个选项是libvirt工具包，它允许您管理多个不同的虚拟化提供程序/管理程序。

#### 练习

1. 下载并安装管理程序
2. 创建一个虚拟机并安装一个linux发行版（例如 [Debian](https://www.debian.org/)）
3. 体验一下快照功能。尝试一个你一直想做的事情，比如运行一个命令```sudo rm -rf --no-preserve-root /```,并看看你是否能轻易恢复
4. 在虚拟机上运行一个逻辑炸弹看看虚拟机的资源隔离室生效
5. 安装虚拟机加载项并体验不同的窗口模式，文件共享和其他特性

### 容器们

虚拟机相对来说还是庞大了一点，如果你想自动化地玩儿转机器怎么办？试试容器吧。

* Amazon firecracker
* Docker
* rkt
* lxc

容器*主要*是各种Linux安全功能的组合，如虚拟文件系统、虚拟网络接口、chroots、虚拟内存技巧等，这些功能一起提供了虚拟化的外观。

不是像虚拟机那样安全或独立，而是非常接近并且越来越好。通常性能更高，启动速度更快，但并非总是如此。

性能提升的原因是，与运行整个操作系统副本的虚拟机不同，容器与主机共享Linux内核。但是，请注意，如果您在Windows/MacOS上运行Linux容器，那么Linux虚拟机将需要处于活动状态，作为两者之间的中间层。

![*Docker容器和虚拟机的比较Credit: blog.docker.com*](./imgs/Blog.-Are-containers-..VM-Image-1.png)

当您希望在标准设置中运行自动化任务时，容器非常方便：

* 构建系统

* 开发环境

* 预打包服务器

* 运行不受信任的程序

  * 对学生提交的材料进行评分

  * （部分）云计算

* 持续集成

  * Travis CI

  * GITHUB 操作

此外，像Docker这样的容器软件也被广泛地用作依赖地狱（[dependency hell](https://en.wikipedia.org/wiki/Dependency_hell)）的解决方案。如果一台机器需要运行许多依赖项冲突的服务，那么可以使用容器隔离这些服务。

通常，编写一个定义如何构造容器的文件。从一些最小的基本映像（如Alpine Linux）开始，然后运行一系列命令来设置所需的环境（安装包、复制文件、构建内容、写入配置文件等）。通常，还有一种方法可以指定任何应该可用的外部端口，以及一个入口点，它指示在容器启动时应该运行什么命令（如分级脚本）。

与代码存储库网站（如GitHub）类似，有些容器存储库网站（如Docker Hub）中的许多软件服务都有可以轻松部署的预构建图像。

#### 练习

选择一个容器软件（docker，lxc，…）并安装一个简单的Linux映像。试着用ssh输入。

搜索并下载流行Web服务器（nginx，apache，…）的预构建容器映像。



## Shell和脚本

Shell是你计算机的一个有效的文本界面。

shell 交互式命令行：当您打开一个终端时，会收到什么问候。允许运行程序和命令；常见的是：

* 更改目录的CD
* ls列出文件和目录
* 移动和复制文件的mv和cp

但是shell允许您做更多的事情；您可以调用计算机上的任何程序，并且存在命令行工具来执行您可能想要做的任何事情。而且，它们通常比它们的图形对应的更有效。我们将在这节课上把这些捋一下。

shell提供了一种交互式编程语言（“脚本”）。有许多shell解释器：

* 你可能用过sh或bash。
* 还有匹配语言的shell:csh。
* 或者“更好”的贝壳：鱼，zsh，ksh。

在这节课中，我们将重点放在无处不在的sh和bash上，但是可以随意用其他的。我喜欢fish。

Shell编程是工具箱中非常有用的工具。可以直接在交互式命令行提示符下写入程序，也可以写入文件。```#！/bin/sh```+```chmod+x```使shell可执行。

#### 使用Shell

多次执行命令：

```shell
for i in $(seq 1 5); do echo hello; done
```

有些东西需要解释：

* ``for x in list; do BODY; done``
  * `；`结束命令，相当于换行
    * 分割```list```，并将每一个分配给```x```,并运行循环体
    * 如果拆分到“空白”，就会结束
    * Shell中没有花括号，使用Do+Done包裹循环

* $(seq 1 5)

  * 用参数1和5运行程序seq

  * 用该程序的输出替换整个$()

  * 相当于

    ```for i in 1 2 3 4 5```

* `echo hello`

  * shell 脚本中每样东西都是命令
  * 在这里，运行echo命令，这个命令将打印他的参数，也就是hello
  * 所有命令都从```$PATH```（分号分隔）中搜索

我们还可以这样：

```shell
for f in $(ls); do echo $f; done
```

这个代码将打印出当前目录中的所有文件名。也可以通过=（没有空格）设置变量：

```shell
foo=bar
echo $foo
```

还是有一些‘特殊的“变量的：

* `$1`到`$9`：脚本参数
* `$0`：脚本自身的名称
* `$#`：参数个数
* `$$`：当前shell的进程id

仅仅打印目录名

```shell
for f in $(ls); do if test -d $f; then echo dir $f; fi; done
```



用参数1和5运行程序seq

用该程序的输出替换整个$（）。

相当于
